---
layout: post
title:  "GitHub"
date:   2020-02-02 11:04:13 +0000
description: 
tags: shpargalki github
cover: https://media.proglib.io/posts/2020/01/24/b1060909dfd0eb9e7f4d36eb930b1123.jpg
---


Ветвление Git с примерами из реальной жизни
Разбираемся, как использовать ветвление: создание, обновление, удаление и прочие классные штуки.

Часто используемые ветки
Большинство проектов включают две основные ветки – master и dev. Ветка master используется для продакшна, а dev – для тестирования. Когда новые изменения протестированы в ветке dev, их можно сливать с веткой master и после этого деплоить. Имена ветвей, их количество могут быть другими – это самые распространённые.

Есть важное правило: вы не должны работать с этими ветками напрямую. Для любого изменения в программном проекте надо сначала создать новую ветвь, унаследовавшись от dev и дать ей имя, отражающее сделанное изменение.

Теперь перейдём к реальным примерам ветвления Git, встречающимся в повседневной жизни разработчиков программного обеспечения.

Настройка удалённых и локальных веток
Предположим, есть тестовый репозиторий на GitHub. Перейдём на главную страницу этого репозитория и щёлкнем по разделу 1 branch.


Как можно видеть, здесь только созданная по умолчанию ветка master. Она сообщает, что содержимое домашней страницы репозитория загружается при выборе данной ветки.

Вернёмся на главную страницу и кликнем по выпадающему меню Branch: master. Если написать dev и нажать на появившийся пункт Create branch: dev, можно создать ветку dev в своём удалённом репозитории.


Создание ветки на локальном репозитории
Для просмотра локального репозитория после добавления ветки dev в удалённый репозиторий, используется следующая команда:

        {% highlight css %}
body{            
color: #ffffff;
}
{% endhighlight %}
        
или такая:
{% highlight git %}
            
$git branch –-list

       {% endhighlight %} 

Эта команда выведет в окно терминала локальные ветви.


Чтобы выйти из списка веток, используйте клавишу q.

Для просмотра удалённых веток применяется следующая команда:

            
$git branch –r

        {% highlight js %}
/**
 * Does a thing
 */
function helloWorld(param1, param2) {
  var something = 0;

  // Do something
  if (2.0 % 2 == something) {
    console.log('Hello, world!');
  } else {
    return null;
  }

  // @TODO comment
}
{% endhighlight %}

Получение изменений из удалённого репозитория
Теперь попробуем заставить появиться удалённую ветку dev. Извлечём все последние изменения удалённого репозитория:

            


    
{% highlight git %}

$git fetch –all

{% endhighlight %}    

Теперь dev появилась среди других веток, потому что с помощью git fetch извлекаются последние актуальные метаданные.


Чтобы извлечь и скопировать все изменения из удалённого репозитория, нужно использовать команду git pull:
            
{% highlight git %}

$git pull origin dev (ключевое слово origin указывает на удаленный репозиторий)

{% endhighlight %}    
       
Теперь информация о ветке верна. Чтобы просмотреть удалённые и локальные ветки, можно использовать уже известную команду с другим ключом:

{% highlight sass %}   
//  Статьи на главной 
.post-item
    background: #ffffff
    width: 820px
    height: 100%
    margin: 10px auto
    border-radius: 5px
    border: 1px solid #eee
    &_content
        padding: 10px 20px 
        
        
        
// PAGES
.post
    background: #ffffff
    display:block
    margin: 20px auto
    width: 820px
    padding: 20px
    border: 1px solid #eee
    
    
    
// POSTS

.post-item_content
    img
        width: 100%
.post-link
    font-size: 30px


// IMG COVER

.post_image_cover
    width: 100%
    height: 300px
    display: block
    background-size: cover
    background-position: center
    filter: opacity(30%)
    &:hover
    filter: none

{% endhighlight %}
        

Переключение между ветками
Всё готово к разработке, и непосредственно перед началом нам нужно изменить текущую ветку с master на dev. Сделаем это в локальном репозитории с помощью команды:


{% highlight git %}

$git checkout dev

{% endhighlight %}    

Как говорилось ранее, dev должна быть основной ветвью для разработки и все действия должны начинаться именно из неё.

CRUD операции с ветками
Создание ветви
Создадим новую ветвь из ветви dev:
         
{% highlight git %}

$git branch my-new-faeture

{% endhighlight %}

Снова проверим локальные ветви:

Обновление имени ветки
Чтобы поменять имя существующей ветки, нет необходимости создавать всё сначала т. к. есть специальная команда:

{% highlight git %}

$git branch -m my-bug-fix

{% endhighlight %}
        
Если вы находитесь в другой ветви, вы всё равно можете переименовать любую из них следующим образом:

{% highlight git %}

$git branch -m my-new-faeture my-new-feature

{% endhighlight %}  

Проверим правильность указанных имён:

Коммит ветки
Внесём изменения в файл README.md и проверим локальный репозиторий:

            

{% highlight git %}

$git status

{% endhighlight %}  

        

Перенесём файл в промежуточную область и сделаем коммит:

{% highlight git %}

$git add README.md
$git commit -m "my first commit"

{% endhighlight %}  

        

Проверяем:


Отправка изменений на удалённый сервер
Теперь можно пушить коммит:

        
{% highlight git %}

$git push origin my-new-branch

{% endhighlight %}  


После отправки актуальной информации о ветке в удалённый репозиторий, нужно проверить, всё ли прошло корректно:


Удаление ветки
Если есть необходимость в удалении ветви, переходим в dev (или в любую ветку, которую нужно удалить) и выполняем удаление:

            



{% highlight git %}

$git checkout dev
$git branch -d my-new-branch

{% endhighlight %}  

        

Удаление завершилось неудачно т. к. удаление локальной ветви с помощью команды git branch -d является безопасной операцией. Если ветка имеет статус unpushed или unmerged , её можно удалить только принудительно:

            

{% highlight git %}

$git branch -D my-new-branch

{% endhighlight %}  
        

Как насчёт удаления remote-ветки? Для этой цели у push есть ключ --delete:

            

{% highlight git %}

$git push origin --delete my-new-branch

{% endhighlight %}  
        

Проверим:


Видим, что my-new-branch очищена от всех локальных и удалённых репозиториев.

Проделаем всё сначала и создадим новую ветку, как «правильные ребята»:


Внесём изменения:


Проверим состояние ветки:

            

{% highlight git %}

$git status

{% endhighlight %}  
        

Наблюдаем изменённый файлик README.md, коммитим текущее изменение локального репозитория, добавив файл в промежуточную область:

            

{% highlight git %}

$git add README.md
$git commit -m "my killer feature"

{% endhighlight %}  

Пушим результат на удалённый сервер:

            

{% highlight git %}

$git push origin feature/my-killer-feature

{% endhighlight %}  
        
        

Теперь предположим, что ваш коллега нашёл какой-то баг в коде, исправил его и создал копию данной ветки с другим именем: fix/my-killer-feature-bug-fix.

Слияние ветвей
Как обычно, сначала получаем актуальную информацию о репозитории:


Далее ищем ветку, над которой работал коллега:


Теперь можно сливать исправленную ветку с feature/my-killer-feature с помощью команды git merge (убедитесь, что находитесь в нужной ветви).

            

{% highlight git %}

$git merge origin/fix/my-killer-feature-fix

{% endhighlight %}  
        

Проверяем конечный результат:

